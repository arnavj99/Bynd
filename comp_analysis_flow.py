# -*- coding: utf-8 -*-
"""Comp Analysis Flow.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1G3BXf8_IVkjGOb9fAUQzVgEol6aQcPZH
"""

# Import necessary libraries
import pandas as pd
import requests
from openpyxl import Workbook

pip install streamlit pyngrok

pip install openbb --no-cache-dir

from openbb_terminal.sdk import openbb

import pandas as pd
openbb.keys.fmp(key = '7DmAtMm8HX92DK5aLmWyGKoav9nwoNhL', persist = True)

def get_dataframes(ticker):
  cash_flow = openbb.stocks.fa.cash(symbol = ticker)
  income = openbb.stocks.fa.income(ticker)
  balance = openbb.stocks.fa.balance(symbol = ticker)
  growth_ratios = openbb.stocks.fa.growth(ticker)
  earnings = openbb.stocks.fa.earnings(ticker, quarterly = True)
  statements = openbb.stocks.fa.sec(ticker)
  ratios = openbb.stocks.fa.ratios(ticker)
  key_metrics = openbb.stocks.fa.key(ticker)
  dataframes_mapping =  {
    'cash_flow': cash_flow,
    'income': income,
    'balance': balance,
    'growth_ratios': growth_ratios,
    'ratios': ratios,
    'keyMetrics': key_metrics
  }
  return dataframes_mapping

"""# Consolidate list of financial metrics available via openBB:"""

def get_available_metrics(dataframes):
    metrics = set()  # Use a set to avoid duplicate metrics
    for df in dataframes:
        metrics.update(df.index.tolist())
    return list(metrics) # Convert to list and sort for a consistent order

"""# Get mapping of metrics to appropriate DataFrame"""

def create_metrics_mapping(dataframes):
    metrics_mapping = {}
    for df_name, df in dataframes.items():
        for metric in df.index:
            metrics_mapping[metric] = df_name
    return metrics_mapping

"""# TODO : Get user input on metrics and tickers with streamlit - not using currently"""

def get_user_input(available_metrics):
    st.sidebar.header('User Input')
    tickers = st.sidebar.text_input("Enter the company tickers (comma separated):")
    tickers = [ticker.strip() for ticker in tickers.split(',')]  # Cleaning up the tickers
    selected_metrics = st.sidebar.multiselect('Select the financial metrics:', available_metrics)
    return tickers, selected_metrics

def validate_input(tickers, selected_metrics):
    if not tickers or not selected_metrics:
        st.error('Please enter both tickers and select at least one metric.')
        return False
    return True

"""# Fetch the selected metrics from the appropriate DataFrames for each ticker."""

def fetch_selected_metrics(ticker, selected_metrics, dataframes, metrics_mapping):
    data = pd.DataFrame(index=[ticker], columns=selected_metrics)  # Initialize DataFrame with ticker as index and metrics as columns
    for metric in selected_metrics:
        df_name = metrics_mapping[metric]
        df = dataframes[df_name]
        value = df.loc[metric].values[0]
        # Check if the value is a number and greater than 1000
        if isinstance(value, (int, float)) and value > 100000:
            value /= 1e6  # Convert to millions
        data.loc[ticker, metric] = value  # Assume the most recent data is needed
    return data

"""# Generate Excel File"""

def generate_excel(data, file_name='comparative_analysis.xlsx'):
    # Export the DataFrame to an Excel file
    with pd.ExcelWriter(file_name, engine='openpyxl') as writer:
        data.to_excel(writer)
        for column in data.columns:
            if (data[column] <= 1).all():  # Check if all values in the column are less than or equal to 1
                col_num = data.columns.get_loc(column) + 1  # +1 because Excel uses 1-indexing
                for row_num in range(2, len(data) + 2):  # +2 because Excel uses 1-indexing and there's a header row
                    cell = writer.sheets['Sheet1'].cell(row=row_num, column=col_num)
                    cell.number_format = '0.00%'
    print(f'Data exported to {file_name}')

"""# Take user input"""

def get_user_inputs(tickers, available_metrics):
    # Print the available metrics
    print(f'Available Metrics: {", ".join(available_metrics)}')

    # Get the metrics from the user
    selected_metrics_input = input("Enter the financial metrics (comma separated): ")
    selected_metrics = [metric.strip() for metric in selected_metrics_input.split(',')]  # Cleaning up the metrics

    return selected_metrics

def validate_input(tickers, selected_metrics):
    if not tickers or not selected_metrics:
        print('Error: Please enter both tickers and select at least one metric.')
        return False
    return True

"""# Main Function"""

def main():
    # Get the tickers from the user
    tickers_input = input("Enter the company tickers (comma separated): ")
    tickers = [ticker.strip() for ticker in tickers_input.split(',')]  # Cleaning up the tickers

    # Get the dataframes for the tickers
    all_dataframes = {ticker: get_dataframes(ticker) for ticker in tickers}

    # Get the available metrics from the dataframe of the first ticker
    available_metrics = get_available_metrics(next(iter(all_dataframes.values())).values())

    # Get user inputs for metrics
    selected_metrics = get_user_inputs(tickers, available_metrics)
    # Validate the input
    if not validate_input(tickers, selected_metrics):
        return

    # Fetch the selected metrics for each ticker
    all_data_local = pd.DataFrame()
    for ticker in tickers:
        dataframes = all_dataframes[ticker]
        metrics_mapping = create_metrics_mapping(dataframes)
        ticker_data = fetch_selected_metrics(ticker, selected_metrics, dataframes, metrics_mapping)
        all_data_local = pd.concat([all_data_local, ticker_data])
        generate_excel(all_data_local)
    print(all_data_local)
    print('Comparative analysis exported to comparative_analysis.xlsx')
# Running the main function when the script is executed
if __name__ == "__main__":
    main()

## AJ TEST comment to see if commit is working
